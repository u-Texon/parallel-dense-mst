\section{Implementierung}\label{Implementierung}
Auch wenn man mittels asymptotischer Laufzeitanalyse Algorithmen sinnvoll miteinander vergleichen kann, geben sie nur einen Einblick in das theoretische Verhalten. Insbesondere stimmen die theoretischen Modelle nicht mit den real-existierenden Maschinen überein. Damit sind diese oft sehr pessimistisch und die tatsächlichen Ergebnisse können in der Praxis stark schwanken.\\
Aus diesem Grund klären wir im Folgenden Details, die unsere Implementierung betroffen haben sowie die Art und Weise wie wir unsere Eingabegraphen konstruiert haben.\\
Die Programmierung unserer Algorithmen \footnote{\url{https://github.com/u-Texon/parallel-dense-mst}} ist in der Programmiersprache $C$++ einstanden unter Verwendung verschiedener Bibliotheken. So haben wir für die Kommunikation zwischen Prozessoren das \textbf{M}essage \textbf{P}assing \textbf{I}nterface (MPI) verwendet. MPI ermöglicht einen einfachen und gezielten Umgang und bietet auch eine Vielzahl an kollektiven Operationen an.
Für die Generierung der Eingabegraphen haben wir \textit{KaGen}\footnote{\url{https://github.com/KarlsruheGraphGeneration/KaGen}} \cite{funke2017communication,HubSan2020RMAT} verwendet und zum Sortieren (z.B bei Kruskals Algorithmus) 
\textit{IpsoSort}\footnote{\url{https://github.com/SaschaWitt/ips4o}} \cite{axtmann2017}. Dieser Sortieralgorithmus kann sowohl parallel als auch sequenziell verwendet werden. Da wir in den Algorithmen nur sequenziell Sortieren, haben wir den parallelen Algorithmus auch nicht verwendet.


\subsection{Zeitmessung}
Damit die Laufzeitmessung unserer Algorithmen auf mehreren Prozessoren funktioniert, wird vor dem Start-Aufruf des Timers immer eine Barriere aufgerufen, die so lange das Programm anhält bis alle Prozessoren an dieser Stelle im Code angekommen sind (und auch die Barriere aufrufen). Erst ab diesem Punkt fängt die Zeit an zu laufen. Mit demselben Vorgehen wird vor dem Stoppen des Timers auch über eine Barriere sichergestellt, dass alle Prozessoren am Ende der Ausführung angekommen sind. Erst dann wird die Zeit angehalten.

Das bedeutet im Wesentlichen, dass ein Timer Aufruf auch immer zwangsläufig ein Barrieren Aufruf beinhaltet. Somit wird zusätzliche Zeit benötigt, um darauf zu warten, dass alle Prozessoren dieselben Codebereiche ausgeführt haben. \\
Da wir für alle Algorithmen nicht nur die gesamte Laufzeit, sondern auch einzelne Phasen der Algorithmen messen wollen, sind wir wie folgt vorgegangen: Für die Evaluation jeglicher Weakscaling Ergebnisse, haben wir nur die Gesamtlaufzeit der Algorithmen gemessen. Das bedeutet wir haben nur einen Timeraufruf vor und nach dem Algorithmus ausgeführt, damit zusätzliche Synchronisatione des Timers keine Auswirkung auf die Algorithmen haben.\\
Bei den Messungen der einzelnen Phasen eines Algorithmus, können wir dieses Problem allerdings nicht umgehen. Daher sollte man beachten, dass einerseits die Gesamtlaufzeit ggf. höher ist als bei den Weakscaling Ergebnissen. Anderseits können Phasen wie das Allreduce bei dem \boruvkaAllreduce Algorithmus geringer erscheinen als sie im Normalfall sind. Das liegt daran, dass für ein Allreduce eine Synchronisation aller Prozessoren für den Nachrichtenaustausch stattfindet. Sollte also ein einzelner Prozessor länger für eine vorherige Aufgabe benötigen als die übrigen, so gehört zum Allreduce das Warten auf diesem Prozessor dazu. Da wir in unserem Fall aber über den Timer Aufruf alle Prozessoren vor dem Allreduce Aufruf synchronisieren, dauert das Warten auf einen einzelnen Prozessor im Anschluss nicht so lange wir üblich.


\subsection{Generierung der Graphen}
Die von uns verwendete KaGen Bibliothek generiert abhängig von der Anzahl an $n$ Knoten, $m$ Kanten, $p$ Prozessoren und Graphtyp $t$ einen bestimmten Graphen. Für diese Generierung muss $p,m,n \in \{2^k | k \in \mathbb{N}\}$ gelten. Daher haben wir unsere Implementierung nur mit einer Zweierpotenz an Prozessoren, Kanten und Knoten evaluiert und getestet. Auch wenn die Algorithmen mit beliebigen Eingaben und Konfigurationen funktionieren. \\
Nach der Generierung liegt der Graph global lexikographisch sortiert auf den einzelnen Prozessoren vor. Zusätzlich wird zu jeder Kante $(s,t,w)$ auch die Rückkante $(t,s,w)$ generiert. 
Allerdings können die verwendeten Algorithmen auch auf zufällig permutierten Kantenlisten arbeiten. Weil wir eventuelle Auswirkungen einer sortierten Eingabe ausschließen möchten, wurde die global sortierte Kantenliste zufällig auf alle PEs verteilt. 
Zu den wesentlichen Graph Typen, die wir verwendet haben gehören GNM, RHG und Pair. 
Bei der Generierung von GNM Graphen mit $n$ Knoten wird $m$ mal zwischen zwei zufälligen Knoten eine Kante gezogen.
Bei RHG Graphen hingegen werden zunächst $n$ Punkte auf einem Kreis mit Radius $R$ gesetzt. Mit weiteren Parametern kann gesteuert werden, wie nah diese Punkte an dem Kreisradius liegen sollen. Zwischen zwei Knoten verläuft eine Kante, wenn der \emph{hyperbolische Abstand} kleiner als $R$ ist. \\

\subsubsection{Pair Graph}
Der Pair Graph ist ein von uns erstellter Graph beruhend auf der Idee von Dehne und Götz \cite{dehne1998practical} mit dem Ziel möglichst viele Iterationen in \boruvkasAlgorithmus zu erzwingen.\\
In jeder Iteration von \boruvkasAlgorithmus verringert sich die Knotenanzahl um mindestens die Hälfte. Besonders auf dichten Graphen, können in einem Schritt eine Vielzahl von Knoten kontrahiert werden, sodass \boruvkasAlgorithmus deutlich weniger als $\log(n)$ Iterationen benötigt. Um aber explizit dieses Szenario betrachten zu können, haben wir mit der Beschreibung  einen eigenen Pair Graphen generiert.

Das Vorgehen zum Generieren eines solchen Graphen ist relativ simpel, besonders für uns, da wir nur Graphen mit $n = 2^k$ betrachten: \\
Wir erstellen zunächst zwischen jedem Zweierpaar an Knoten eine Kante mit Gewicht 1, anschließend zwischen jedem Viererpaaren mit Gewicht 2, dann zwischen Achterpaaren mit Gewicht 3 und so weiter. Somit generieren wir insgesamt n-1 Kanten und können weitere zufällige Kanten (mit minimalem Gewicht von n) hinzufügen. 
Eine schematische Darstellung eines Pair Graphen mit 8 Knoten ist in Abbildung \cref{Pair-Graph-Img} dargestellt.

Durch die geringen Kantengewichte stellen wir sicher, dass es sich bei all diese Kanten genau um die MST-Kanten des Graphen handelt. Im ersten Borvkaschritt werden also alle Knotenpaare die über eine Kante mit Gewicht eins verbunden sind kontrahiert, im nächsten Schritt diejenigen Paare, die über Gewicht zwei verbunden sind und so weiter. Damit ergibt sich für einen Pair Graphen immer die maximal mögliche Anzahl von $\log(n)$ Iterationen für Bor{\r u}vkas Algorithmus.

\begin{figure}[H]
    \centering
    \includesvg[width=12cm]{Figures/PAIR-Graph.svg}
    \caption{Pair Graph mit $n=8$}
    \label{Pair-Graph-Img}
\end{figure}


